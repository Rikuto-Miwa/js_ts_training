# コレクション（30問）
1. 配列リテラルと`Array`コンストラクタで配列を生成する場合の違いと、推奨される方法を説明してください。
2. 配列の`length`プロパティを書き換えると要素にどんな影響があるか、伸長/縮小それぞれで説明してください。
3. `push`/`pop`/`shift`/`unshift`の挙動と、パフォーマンス上の違いを説明してください。
4. `slice`と`splice`の違いを、戻り値と元配列への影響の観点から説明してください。
5. `map`と`forEach`の役割の違いを説明し、それぞれ適したケースを挙げてください。
6. `filter`と`find`の違いを説明し、返される値の型を明示してください。
7. `reduce`で配列の合計値を求める基本形を書き、初期値が無い場合の挙動と注意点を説明してください。
8. `reduce`でオブジェクトへの集計（例: カテゴリ別カウント）を行うサンプルを書いてください。
9. `some`と`every`の短絡評価の仕組みを説明し、戻り値と実行停止のタイミングを述べてください。
10. `includes`と`indexOf`の違いを説明し、`NaN`の扱いに注目してください。
11. 配列のソートがデフォルトで文字列比較になることによる問題と、数値ソートのための比較関数例を示してください。
12. `Array.from`の用途を2つ挙げ、マップ関数引数の使い方を示してください。
13. スプレッド構文で配列をコピーする場合の注意点（浅いコピー）と、ネストした配列での影響を説明してください。
14. `flat`と`flatMap`の違いを説明し、ネスト深さを指定する方法を示してください。
15. Setを使って配列の重複を排除する方法と、その後配列に戻す書き方を示してください。
16. `Set`の`add`/`has`/`delete`/`clear`の基本操作と、挿入順が保持されることを説明してください。
17. `WeakSet`の特徴（参照の弱さと非列挙性）と、典型的な用途を挙げてください。
18. `Map`とプレーンオブジェクトの違いを、キーの型と列挙順の観点で説明してください。
19. `Map`の`set`/`get`/`has`/`delete`/`clear`を使った基本操作の例を書いてください。
20. `Map`の`forEach`と`for...of`（`[key, value]`の反復）の違いを説明してください。
21. `WeakMap`の主な用途と、キーや列挙に関する制約を説明してください。
22. `for...of`と`for...in`の違いを、反復対象・列挙される値・典型的用途の観点で説明してください。
23. 反復可能オブジェクトの条件（`Symbol.iterator`実装）を説明し、カスタムイテレーターの簡単な例を書いてください。
24. ジェネレーター関数（`function*`）で`yield`を使い、逐次値を生成する例を示してください。
25. ジェネレーターの`next`・`return`・`throw`がそれぞれ何を行うか説明してください。
26. 無限シーケンスをジェネレーターで表現する場合の注意点と、使用時に短絡させる方法を説明してください。
27. 文字列や`Set`を`for...of`で反復したときに得られる値を説明してください。
28. 配列の`entries`/`keys`/`values`メソッドの違いを説明し、`for...of`での利用例を示してください。
29. イミュータブルな配列操作を行うための代表的な手法を2つ挙げてください。
30. コレクション操作におけるパフォーマンスを評価するとき、どんな観点（計算量・再割り当て・イテレーション回数など）を確認すべきか述べてください。
