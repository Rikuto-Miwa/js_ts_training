# オブジェクトとプロトタイプ（30問）
1. プリミティブ型とオブジェクト型の違いを、ミュータビリティと参照渡しの観点で説明してください。
2. オブジェクトリテラルでプロパティ名と変数名が同じ場合の省略記法と、計算されたプロパティ名の記述例を示してください。
3. ドット記法とブラケット記法の違いを説明し、ブラケット記法が必要になる代表的なケースを挙げてください。
4. プロパティを追加/更新/削除するそれぞれの方法（代入・`Object.assign`・`delete`など）と挙動の違いを説明してください。
5. `in`演算子と`hasOwnProperty`の違いを説明し、どちらを使うべきか判断する基準を述べてください。
6. 列挙可能性とプロパティディスクリプタ（`writable`/`enumerable`/`configurable`）を取得する方法を説明してください。
7. `Object.keys`・`Object.values`・`Object.entries`の違いを示し、順序の扱いについて説明してください。
8. オブジェクトの浅いコピーを作る方法（スプレッド構文や`Object.assign`）と、ネストしたオブジェクトでの落とし穴を説明してください。
9. 深いコピーを必要とする理由と、`structuredClone`やJSON経由コピーの制約を説明してください。
10. プロトタイプチェーンとは何か、プロパティ解決がどのように行われるかを説明してください。
11. `Object.getPrototypeOf`と`Object.setPrototypeOf`の役割を説明し、パフォーマンス上の注意点を述べてください。
12. `Object.create(null)`で生成したオブジェクトが通常のリテラルと異なる点を説明してください。
13. コンストラクタ関数と`class`構文の基本的な違いを説明し、同等の機能を持つ例を示してください。
14. `class`で定義したメソッドが内部的にどこへ格納されるかを説明してください。
15. コンストラクタで`return`を明示した場合の挙動を、オブジェクトとプリミティブで比較してください。
16. `extends`を使ってサブクラスを定義する基本的な構文と、プロトタイプチェーンがどう構築されるか説明してください。
17. サブクラスのコンストラクタで`super()`を呼び出す理由と、呼び出さないとどうなるかを説明してください。
18. クラスメソッドで`super.method()`を呼ぶ際に`this`がどのように設定されるか説明してください。
19. 静的メソッドとインスタンスメソッドの違いと、それぞれに適した処理の例を挙げてください。
20. プライベートフィールド（`#field`）の特徴と、アクセス時の制約を説明してください。
21. ゲッター/セッターをクラスやオブジェクトリテラルで定義する方法と用途を説明してください。
22. `this`がメソッド参照をコールバックに渡したときに失われる原因と、`bind`やアロー関数での対策を説明してください。
23. `instanceof`演算子の判定ロジックと、`Symbol.hasInstance`をカスタマイズするとどうなるか説明してください。
24. プロトタイプを直接書き換える（例: `Foo.prototype.bar = ...`）場合の利点とリスクを説明してください。
25. `for...in`がプロトタイプ経由のプロパティも列挙する点を踏まえた対策を説明してください。
26. `Object.freeze`と`Object.seal`の違いを説明し、`freeze`後もミュータブルな値が残るケースを挙げてください。
27. シンボルプロパティを列挙する方法と、シンボルをキーに使う利点を説明してください。
28. `toString`や`valueOf`をオーバーライドする目的と、デバッグ時の注意点を述べてください。
29. ビルトインオブジェクト（`Array`や`Date`など）を継承する際の注意点と、`super`呼び出しの順序を説明してください。
30. プロトタイプベースの設計で避けたいアンチパターンを2つ挙げ、改善策を提案してください。
