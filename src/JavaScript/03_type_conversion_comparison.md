# 型変換と比較（30問）
1. truthyとfalsyに分類される代表的な値をそれぞれ5つ挙げ、`Boolean()`での変換結果を確認してください。
2. 二重否定演算子`!!`を用いた真偽値変換の意味と使いどころを説明してください。
3. 文字列を数値に変換する手段（`Number`/`parseInt`/`parseFloat`/単項+）の違いと使い分けを説明してください。
4. `parseInt`で基数を指定しないと起こり得る問題と、必ず基数を渡すべき理由を述べてください。
5. `Number("  42  ")`や`Number("42px")`が返す値を予想し、理由を説明してください。
6. `Number.isFinite`とグローバル`isFinite`の挙動の違いを例で示してください。
7. `Number.isInteger`が真を返す条件を説明し、`1.0`や`Infinity`の場合の結果を予想してください。
8. 単項`+`を配列や日付に対して使ったときに内部で行われる`ToPrimitive`変換を説明してください。
9. オブジェクトが数値に強制変換されるとき、`valueOf`と`toString`はどの順番で呼ばれるか説明してください。
10. 文字列連結のためにオブジェクトが文字列化される際の挙動を、独自`toString`を持つオブジェクトの例で示してください。
11. `==`が暗黙の型変換を行う代表的なパターン（`null`と`undefined`など）を3つ挙げてください。
12. `null == undefined`が真になる理由と、`null === undefined`が偽になる理由を説明してください。
13. `0 == false`が真になるのに対し、`0 === false`が偽になる理由を述べてください。
14. 空文字`""`や空配列`[]`が`==`比較でどのように扱われるか、具体例を挙げて説明してください。
15. `[] == 0`や`[] == ""`の結果を予想し、内部で行われる変換手順を解説してください。
16. `NaN === NaN`が偽になる理由と、`Number.isNaN`で判定するべき理由を説明してください。
17. `Object.is`が`===`と異なる結果を返す2つのケースを挙げ、その理由を述べてください。
18. `==`でオブジェクト同士を比較すると必ず参照比較になる理由を説明してください。
19. `===`で配列やオブジェクトを比較したときに等しくならない典型的な例を挙げてください。
20. `Symbol`値を文字列や数値に暗黙変換しようとしたときに起こる結果を説明してください。
21. BigIntとNumberを混在させた比較や加算で発生するエラー/挙動を説明してください。
22. `localeCompare`を使った文字列比較と、`>`や`<`による単純比較の違いを説明してください。
23. `Array.prototype.sort`がデフォルトで文字列比較を行うことによる問題と、数値ソートのための対策を説明してください。
24. オプショナルチェーン`?.`の評価結果が`undefined`になるとき、`== null`比較がどのように振る舞うか確認してください。
25. `||`によるデフォルト値設定が期待通り動かないケース（`0`や`""`など）と、その解決策としての`??`の使い方を説明してください。
26. `Boolean([])`や`Boolean({})`が`true`になる理由を説明し、実用上の落とし穴を挙げてください。
27. 日付オブジェクト同士を`>`や`<`で比較するときに内部で行われる変換を説明してください。
28. `==`の抽象的等価性比較アルゴリズムで「型が違う場合」に行われる大まかな手順を要約してください。
29. 文字列と数値の比較（例: `"5" > 12`）がどのように評価されるか、結果と理由を説明してください。
30. 暗黙の型変換を抑制し、安全な比較を行うための実践的なガイドラインを3つ挙げてください。
