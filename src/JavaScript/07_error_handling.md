# エラーハンドリング（30問）
1. `try...catch...finally`の基本的な実行フローを説明し、例外が発生しない場合でも`finally`が実行されるか述べてください。
2. `finally`ブロック内で`return`や`throw`を行った場合、元の戻り値や例外にどんな影響が出るか説明してください。
3. `throw`できる値の種類と、`Error`オブジェクトを投げることが推奨される理由を説明してください。
4. `Error`オブジェクトの主なプロパティ（`name`/`message`/`stack`）を説明し、`stack`を表示する際の注意点を述べてください。
5. `SyntaxError`・`TypeError`・`ReferenceError`など組み込みエラー種別の使い分けを説明してください。
6. ユーザー定義エラークラスを`class CustomError extends Error`で作る際、`super(message)`を呼ぶ理由と`name`の扱いを説明してください。
7. `cause`オプション付きで`new Error`を生成する例を書き、入れ子の原因を追跡する利点を説明してください。
8. `try...catch`が同期エラーにしか効かない理由と、非同期処理でのエラー捕捉方法を説明してください。
9. `async/await`で`try...catch`を用いてPromise拒否を捕捉する基本パターンを書いてください。
10. `Promise.prototype.catch`チェーンでエラーをまとめて扱う例を書き、`catch`の戻り値が後続にどう渡るか説明してください。
11. `Promise.all`で一つのPromiseが拒否されたときの挙動と、全体の結果がどうなるか説明してください。
12. `Promise.allSettled`を使うとどんな結果が得られるか、`all`との違いを説明してください。
13. `Promise.any`が全て拒否されたときに投げるエラーの型と、中身を確認する方法を説明してください。
14. `unhandledrejection`イベントが発火する条件と、ブラウザでの基本的なハンドリング方法を説明してください。
15. Fetch APIでネットワークエラーとHTTPエラーを区別する方法を説明してください。
16. `throw`したエラーをキャッチした後に再度投げる（再スロー）理由と、再スローの最小限の書き方を示してください。
17. エラーメッセージにユーザーの入力値を含めるときの注意点（情報漏えい・サニタイズ）を説明してください。
18. エラーを握り潰してしまうアンチパターンと、その副作用を2つ挙げてください。
19. ログ出力時に`console.error`と`console.warn`を使い分ける基準を述べてください。
20. `debugger`ステートメントをエラーハンドリング中に活用する場合、どんな状況で役立つか説明してください。
21. スタックトレースを維持したままエラーをラップするパターン（`throw new CustomError('...', { cause: err })`など）の利点を説明してください。
22. Node.jsで扱われる未処理例外（`uncaughtException`）とブラウザでの未捕捉エラー（`error`イベント）の違いを説明してください。
23. リトライ処理を行うときに考慮すべき点（回数・待機・冪等性）を3つ挙げてください。
24. 入力検証エラーとシステムエラーを区別して扱うメリットを説明してください。
25. 非同期ストリームやイベントリスナーでエラー通知を受け取る典型的な方法（コールバックの第1引数や`error`イベントなど）を説明してください。
26. エラーハンドリングをテストする際に、どのようにして例外発生をシミュレーションするか具体例を挙げてください。
27. UIでユーザーにエラーを伝える際のベストプラクティス（簡潔さ、再試行手段、問い合わせ先など）を3つ挙げてください。
28. 非同期関数内で`try`を深くネストさせないためのリファクタリング手法を2つ挙げてください。
29. エラー情報を外部監視ツールへ送信する際、個人情報やセキュリティ上の配慮として注意すべき点を述べてください。
30. プロセスやアプリ全体を落とすべき重大なエラーと、復旧可能なエラーをどう見極めるか、判断基準を挙げてください。
