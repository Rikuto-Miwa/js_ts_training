# 関数とスコープ（解答例）
1. 関数宣言はホイスティングされ定義前に呼べる。関数式は変数に束縛されるため代入前は参照不可。
2. 無名関数は簡潔だがスタックトレースが読みにくい。名前付き関数式はデバッグしやすく再帰にも使える。
3. アローは`this`/`arguments`を持たず外側をレキシカルに捕捉し、`prototype`もない。通常関数は動的`this`と`arguments`を持つ。
4. アローは`[[Construct]]`を持たず`prototype`も無いので`new`できない。
5. デフォルト引数は呼び出し時に評価。副作用や`Date.now()`は毎回評価される点に注意。
6. `const sum = (...nums) => nums.reduce((a, b) => a + b, 0);`
7. `arguments`は配列風で実引数全体、レストは実配列で宣言以降のみ。可読性と静的チェックのためレスト推奨。
8. `fn(...arr)`で配列要素を展開して渡す。
9. `call`は引数列、`apply`は配列、どちらも`this`を即座に束縛。`bind`は新関数を返し`this`や先頭引数を固定。
10. `button.addEventListener('click', handler.bind(obj));`
11. スコープチェーンは内→外→グローバルの順で識別子解決する連なり。
12. 競合・副作用・テスト困難がリスク。モジュールスコープ/ブロックスコープを使う、名前空間オブジェクトで隔離する。
13. `let`は反復ごとに新束縛を作るので非同期でも値が保持される。`var`は一つの関数スコープを共有。
14. レキシカルスコープだから内側は外側の環境を参照できる。
15. クロージャ: 外側の変数を保持する関数。`function outer(){let x=1; return ()=>x++;}`
16. 閉じた変数が不要に残ると解放されない。不要な参照を`null`にする/スコープを限定する。
17. IIFEの用途: 一度きりの初期化とスコープ汚染防止、モジュールパターン。
18. 終端が無いと無限再帰でスタックオーバーフロー。必ずベースケースを設ける。
19. 名前付き関数式なら自己参照でき、外側変数名変更の影響を受けにくい。
20. `function setup({ url, timeout = 5000 }) { ... }` のように分割代入で受ける。
21. 高階関数例: `const withLog = (fn)=> (...a)=>{console.log(a); return fn(...a);};` 再利用や合成に利点。
22. 部分適用は先頭引数を固定、カリー化は1引数ずつ返す形で関数合成がしやすい。
23. メソッドをコールバックに渡すと`this`が失われる。`bind`やアローで固定する。
24. `for (let i=0;i<3;i++){ setTimeout(()=>console.log(i),0); }` で正しく捕捉。`let`やIIFEを使う。
25. `with`は識別子解決が曖昧になり最適化できないため非推奨。
26. `eval`は現在スコープに影響し最適化を阻害・セキュリティリスクがあるので避ける。
27. ブロック内関数宣言は仕様で限定され実装差異があったため。ES2015以降はブロック内も許可されるが注意。
28. 第一級: 変数に入れる/引数や戻り値にできる。例: コールバック、イベントハンドラ、関数生成。
29. モジュール内で一度だけ実行して閉じた変数に結果を保持するパターン（IIFEや初期化フラグ）。
30. モジュール分割、ブロックスコープ活用、公開面を最小化し副作用を減らす方針。
