# モジュール（解答例）
1. モジュールはファイル単位スコープ・`defer`相当で順序評価・`this`が`undefined`・重複読込はキャッシュ。
2. 仕様でstrict mode固定。`this`が`undefined`になり、意図しない暗黙グローバルなどがエラーになる。
3. 各モジュールは独立スコープでグローバルへ自動公開しない。
4. 名前付き: `export const x = 1;` や `const x=1; export { x };`
5. デフォルト: `export default function(){}`。インポート時に波括弧不要で名前は自由。名前付きは束縛名が固定。
6. `export { a, b, c };` でまとめて書ける。
7. `import { foo as bar } from './mod.js';`
8. `import Baz from './Baz.js';` で任意名を付けられる。
9. `import * as utils from './utils.js';` 名前空間にまとめたいとき。
10. `import './polyfill.js';` のように副作用目的で読み込む。
11. `export { foo as bar };` で外部API名を調整したい場合に使う。
12. `export { foo } from './a.js';` で再エクスポート。`export * from './a.js';` は全てを再公開（デフォルト除く）。
13. `export { default as Foo } from './Foo.js';`
14. `import('./lazy.js').then(...)` でPromiseが返る。必要なタイミングで遅延読み込み。
15. トップレベル`await`はモジュール/ESMのみで使用可。依存モジュールの評価順をブロックする。
16. 一度評価したモジュールはキャッシュされ再実行されない。副作用初期化は一度きりになる点に注意。
17. エクスポートはライブバインディングで再代入が反映される（ただしインポート側で再代入は不可）。
18. インポートした束縛は読み取り専用。更新したい場合はモジュール側で値を更新するかラッパー関数を提供する。
19. デフォルトは1つのみ。APIの単一エントリに適するが、匿名だと名前がバラバラになりやすい議論がある。
20. 公開APIが複数なら名前付き、単一エクスポートならデフォルトなど、一貫性とツリーシェイクを基準に選ぶ。
21. ESMは静的構造なのでツリーシェイクしやすい。CJSは動的requireで解析が難しい。
22. ブラウザはURLとして扱うため拡張子必須。解決は相対/絶対URLに従う。
23. ベアモジュールは解決できないため、バンドラ/Import Maps/開発サーバで解決させる必要がある。
24. Nodeでは`type: module`や拡張子`.mjs`が必要。CJSとの混在時は`createRequire`や動的`import`を使うなど注意。
25. 循環参照では一部未初期化のエクスポートが渡る可能性。依存を分離し、初期化順を整理する。
26. 非JS資産はローダーやバンドラ設定が必要（webpack loaders, Vite pluginsなど）。
27. インポート順で副作用初期化の順番が変わる。明示的に初期化関数を呼ぶなどで安定させる。
28. デフォルトは1つだけなので波括弧不要。名前付きは束縛名が固定で波括弧必須。
29. モジュールのトップで`this`は`undefined`。モジュールスコープがグローバルではないため。
30. 公開最小化、依存の明示化、循環を避ける、ツリーシェイクしやすい構造にする、といった設計を心掛ける。
